# ------------------------
# Von Misses Truss Example
# ------------------------
using Test, LinearAlgebra, Suppressor
using ONSAS

# Mesh Cube with Gmsh.jl
include(joinpath("..", "uniaxial_extension", "uniaxial_mesh.jl"))

"Return problem parameters"
function parameters()
    E = 1.0                     # Young modulus in Pa
    ŒΩ = 0.3                     # Poisson's ratio
    Œº = G = E / (2 * (1 + ŒΩ))   # Second Lam√© parameter
    K = E / (3 * (1 - 2 * ŒΩ))   # Bulk modulus
    p = 1                       # Pressure load in Pa
    Li = 2.0                    # Dimension in x of the box in m
    Lj = 1.0                    # Dimension in y of the box in m
    Lk = 1.0                    # Dimension in z of the box in m
    ms = 0.5                    # Refinement factor for the mesh
    RTOL = 1e-4                 # Relative tolerance for tests
    ATOL = 1e-10                # Absolute tolerance for tests
    NSTEPS = 9                  # Number of steps for the test
    (; Œº, G, K, p, Li, Lj, Lk, ms, RTOL, ATOL, NSTEPS)
end;

#= -----------------------------------------------------
Two cases are considered:
Case 1 - Manufactured mesh, `NeoHookean` material and GlobalLoad
Case 2 - GMSH mesh and `HyperElastic` material and Pressure
------------------------------------------------------=#
abstract type AbstractCase end
struct FirstCase <: AbstractCase end
struct SecondCase <: AbstractCase end

"Return the boundary conditions"
function boundary_conditions()
    (; p) = parameters()

    bc_fixed_x_label = "fixed-ux"
    bc_fixed_x = FixedDof(:u, [1], bc_fixed_x_label)
    bc_fixed_y_label = "fixed-uj"
    bc_fixed_y = FixedDof(:u, [2], bc_fixed_y_label)
    bc_fixed_k_label = "fixed-uk"
    bc_fixed_k = FixedDof(:u, [3], bc_fixed_k_label)
    bc_load_label = "compression"
    bc_load = GlobalLoad(:u, t -> [-p * t, 0, 0], bc_load_label)
    bc_labels = [bc_fixed_x_label, bc_fixed_y_label, bc_fixed_k_label, bc_load_label]

    (; bc_fixed_x, bc_fixed_y, bc_fixed_k, bc_load, bc_labels)
end;

"Return the first case structural model"
function structure(::FirstCase=FirstCase())
    (; Œº, K, Li, Lj, Lk) = parameters()
    # -------------
    # Mesh
    # -------------
    n‚ÇÅ = Node(0.0, 0.0, 0.0)
    n‚ÇÇ = Node(0.0, 0.0, Lk)
    n‚ÇÉ = Node(0.0, Lj, Lk)
    n‚ÇÑ = Node(0.0, Lj, 0.0)
    n‚ÇÖ = Node(Li, 0.0, 0.0)
    n‚ÇÜ = Node(Li, 0.0, Lk)
    n‚Çá = Node(Li, Lj, Lk)
    n‚Çà = Node(Li, Lj, 0.0)
    vec_nodes = [n‚ÇÅ, n‚ÇÇ, n‚ÇÉ, n‚ÇÑ, n‚ÇÖ, n‚ÇÜ, n‚Çá, n‚Çà]
    mesh = Mesh(; nodes=vec_nodes)
    f‚ÇÅ = TriangularFace(n‚ÇÖ, n‚Çà, n‚ÇÜ, "loaded_face_1")
    f‚ÇÇ = TriangularFace(n‚ÇÜ, n‚Çà, n‚Çá, "loaded_face_2")
    f‚ÇÉ = TriangularFace(n‚ÇÑ, n‚ÇÅ, n‚ÇÇ, "x=0_face_1")
    f‚ÇÑ = TriangularFace(n‚ÇÑ, n‚ÇÇ, n‚ÇÉ, "x=0_face_2")
    f‚ÇÖ = TriangularFace(n‚ÇÜ, n‚ÇÇ, n‚ÇÅ, "y=0_face_1")
    f‚ÇÜ = TriangularFace(n‚ÇÜ, n‚ÇÅ, n‚ÇÖ, "y=0_face_2")
    f‚Çá = TriangularFace(n‚ÇÅ, n‚ÇÑ, n‚ÇÖ, "z=0_face_1")
    f‚Çà = TriangularFace(n‚ÇÑ, n‚Çà, n‚ÇÖ, "z=0_face_2")
    vec_faces = [f‚ÇÅ, f‚ÇÇ, f‚ÇÉ, f‚ÇÑ, f‚ÇÖ, f‚ÇÜ, f‚Çá, f‚Çà]
    append!(faces(mesh), vec_faces)
    ## Entities
    t‚ÇÅ = Tetrahedron(n‚ÇÅ, n‚ÇÑ, n‚ÇÇ, n‚ÇÜ, "tetra_1")
    t‚ÇÇ = Tetrahedron(n‚ÇÜ, n‚ÇÇ, n‚ÇÉ, n‚ÇÑ, "tetra_2")
    t‚ÇÉ = Tetrahedron(n‚ÇÑ, n‚ÇÉ, n‚ÇÜ, n‚Çá, "tetra_3")
    t‚ÇÑ = Tetrahedron(n‚ÇÑ, n‚ÇÅ, n‚ÇÖ, n‚ÇÜ, "tetra_4")
    t‚ÇÖ = Tetrahedron(n‚ÇÑ, n‚ÇÜ, n‚ÇÖ, n‚Çà, "tetra_5")
    t‚ÇÜ = Tetrahedron(n‚ÇÑ, n‚Çá, n‚ÇÜ, n‚Çà, "tetra_6")
    vec_elems = [t‚ÇÅ, t‚ÇÇ, t‚ÇÉ, t‚ÇÑ, t‚ÇÖ, t‚ÇÜ]
    append!(elements(mesh), vec_elems)
    dof_dim = 3
    set_dofs!(mesh, :u, dof_dim)
    # -------------------------------
    # Materials
    # -------------------------------
    neo_hookean = NeoHookean(K, Œº, "NeoBuiltIn")
    materials = StructuralMaterial(neo_hookean => [t‚ÇÅ, t‚ÇÇ, t‚ÇÉ, t‚ÇÑ, t‚ÇÖ, t‚ÇÜ])
    # -------------------------------
    # Boundary conditions
    # -------------------------------
    (; bc_fixed_x, bc_fixed_y, bc_fixed_k, bc_load) = boundary_conditions()
    face_bc = [bc_fixed_x => [f‚ÇÉ, f‚ÇÑ],
               bc_fixed_y => [f‚ÇÖ, f‚ÇÜ],
               bc_fixed_k => [f‚Çá, f‚Çà],
               bc_load => [f‚ÇÅ, f‚ÇÇ]]
    bcs = StructuralBoundaryCondition(face_bc)

    Structure(mesh, materials, bcs)
end;

"Return the second case structural model"
function structure(::SecondCase)
    (; Œº, K, p, Li, Lj, Lk, ms) = parameters()
    # -------------------------------
    # Materials
    # -------------------------------
    "Neo-Hookean strain energy function given the Green-Lagrange strain
    tensor `ùîº`, second lam√© parameter `Œº` and bulk modulus `K`."
    function strain_energy_neo(ùîº::AbstractMatrix, K::Real, Œº::Real)
        # Right hand Cauchy strain tensor
        ‚ÑÇ = Symmetric(2 * ùîº + eye(3))
        J = sqrt(det(‚ÑÇ))
        # First invariant
        I‚ÇÅ = tr(‚ÑÇ)
        # Strain energy function
        Œ® = Œº / 2 * (I‚ÇÅ - 2 * log(J)) + K / 2 * (J - 1)^2
    end
    # The order must be the same defined in the strain energy (splatting)
    params = [K, Œº]
    mat_label = "neoHyper"
    neo_hookean_hyper = HyperElastic(params, strain_energy_neo, mat_label)
    materials = StructuralMaterial(neo_hookean_hyper)
    # -------------------------------
    # Boundary Conditions
    # -------------------------------
    (; bc_fixed_x, bc_fixed_y, bc_fixed_k, bc_labels) = boundary_conditions()
    bc_load = Pressure(:u, t -> p * t, last(bc_labels))
    bcs = StructuralBoundaryCondition(bc_fixed_x, bc_fixed_y, bc_fixed_k, bc_load)
    # -------------------------------
    # Entities
    # -------------------------------
    faces_label = "triangle"
    elems_label = "tetrahedron"
    vfaces = [TriangularFace(faces_label)]
    velems = [Tetrahedron(elems_label)]
    s_entities = StructuralEntity(velems, vfaces)
    entities_labels = [faces_label, elems_label]
    # -------------------------------
    # Mesh
    # -------------------------------
    filename = "uniaxial_compression"
    labels = [mat_label, entities_labels, bc_labels]
    local mesh_path
    output = @capture_out begin
        mesh_path = create_uniaxial_mesh(Li, Lj, Lk, labels, filename, ms)
    end
    gmsh_println(output)
    msh_file = MshFile(mesh_path)
    mesh = Mesh(msh_file, s_entities)
    dof_dim = 3
    set_dofs!(mesh, :u, dof_dim)
    apply!(materials, mesh)
    apply!(bcs, mesh)

    Structure(mesh, materials, bcs)
end;

"Return the problem solution"
function solve(case::AbstractCase)
    (; NSTEPS) = parameters()
    # -------------------------------
    # Structural Analysis
    # -------------------------------
    s = structure(case)
    sa = NonLinearStaticAnalysis(s; NSTEPS)
    reset!(sa)
    # -------------------------------
    # Solver
    # -------------------------------
    tol_f = 1e-10
    tol_u = 1e-10
    max_iter = 30
    tols = ConvergenceSettings(tol_u, tol_f, max_iter)
    nr = NewtonRaphson(tols)
    # -------------------------------
    # Numerical solution
    # -------------------------------
    solve!(sa, nr)
end;

sa = solve(FirstCase())

#= TODO: REVISIT THIS TESTS

function run_uniaxial_compression()
    "Computes numeric solution Œ±(L_def/L_ref), Œ≤(L_def/L_ref) and Œ≥(L_def/L_ref)
    for analytic validation."
    function Œ±Œ≤Œ≥_numeric(states_sol::AbstractSolution)
        s = structure(analysis(states_sol))
        # Node at (Li, Lj, Lk)
        n‚Çá = nodes(s)[7]
        displacements_n‚Çá = displacements(states_sol_case‚ÇÅ, n‚Çá)
        # Displacements in the x (component 1) axis at node 7
        numerical_u·µ¢ = displacements_n‚Çá[1]
        numerical_Œ± = 1 .+ numerical_u·µ¢ / Li
        # Displacements in the y (component 2) axis at node 7
        numerical_u‚±º = displacements_n‚Çá[2]
        numerical_Œ≤ = 1 .+ numerical_u‚±º / Lj
        # Displacements in the z (component 3) axis at node 7
        numerical_u‚Çñ = displacements_n‚Çá[3]
        numerical_Œ≥ = 1 .+ numerical_u‚Çñ / Lk
        numerical_Œ±, numerical_Œ≤, numerical_Œ≥, numerical_u·µ¢, numerical_u‚±º, numerical_u‚Çñ
    end
    # Numeric solution for testing
    numeric_Œ±_case‚ÇÅ, numeric_Œ≤_case‚ÇÅ, numeric_Œ≥_case‚ÇÅ, numeric_u·µ¢_case‚ÇÅ, _, _ = Œ±Œ≤Œ≥_numeric(states_sol_case‚ÇÅ)
    # Extract ‚Ñô and ‚ÑÇ from the last state using a random element
    e = rand(elements(s‚ÇÅ))
    # Cosserat or second Piola-Kirchhoff stress tensor
    ‚Ñô_numeric_case‚ÇÅ = stress(states_sol_case‚ÇÅ, e)
    # ‚Ñô·µ¢·µ¢ component:
    ‚Ñô·µ¢·µ¢_numeric_case‚ÇÅ = getindex.(‚Ñô_numeric_case‚ÇÅ, 1, 1)
    # ‚Ñô‚±º‚±º component:
    ‚Ñô‚±º‚±º_numeric_case‚ÇÅ = getindex.(‚Ñô_numeric_case‚ÇÅ, 2, 2)
    # ‚Ñô‚Çñ‚Çñ component:
    ‚Ñô‚Çñ‚Çñ_numeric_case‚ÇÅ = getindex.(‚Ñô_numeric_case‚ÇÅ, 3, 3)
    # Get the Right hand Cauchy strain tensor ‚ÑÇ at a random state
    ‚ÑÇ_rand_numeric_case‚ÇÅ = rand(strain(states_sol_case‚ÇÅ, e))
    # Get the Second Piola Kirchhoff stress tensor ‚Ñô at a random state
    ‚Ñô_rand_numeric_case‚ÇÅ = rand(stress(states_sol_case‚ÇÅ, e))
    # Load factors
    load_factors_case‚ÇÅ = load_factors(sa)
    # -----------------------------------------------
    # Case 2 - GMSH mesh and `HyperElastic` material
    #------------------------------------------------
    # -------------------------------
    # Materials
    # -------------------------------
    # Define a new HyperElastic material from the strain energy function
    "Neo-Hookean strain energy function given the Green-Lagrange strain
    tensor `ùîº`, second lam√© parameter `Œº` and bulk modulus `K`."
    function strain_energy_neo(ùîº::AbstractMatrix, K::Real, Œº::Real)
        # Right hand Cauchy strain tensor
        ‚ÑÇ = Symmetric(2 * ùîº + eye(3))
        J = sqrt(det(‚ÑÇ))
        # First invariant
        I‚ÇÅ = tr(‚ÑÇ)
        # Strain energy function
        Œ® = Œº / 2 * (I‚ÇÅ - 2 * log(J)) + K / 2 * (J - 1)^2
    end
    params = [K, Œº] # The order must be the same defined in the strain energy (splatting)
    mat_label = "neoHyper"
    neo_hookean_hyper = HyperElastic(params, strain_energy_neo, mat_label)
    # Material types without assigned elements
    materials = StructuralMaterial(neo_hookean_hyper)
    # -------------------------------
    # Boundary Conditions
    # -------------------------------
    # Redefine the load boundary condition
    bc_load = Pressure(:u, t -> p * t, bc‚ÇÑ_label)
    # BoundaryConditions types without assigned node, feces and elements
    s_boundary_conditions = StructuralBoundaryCondition(bc_fixed_x, bc_fixed_y, bc_fixed_k, bc_load)
    # -------------------------------
    # Entities
    # -------------------------------
    # Entities types without assigned nodes, faces and elements
    faces_label = "triangle"
    elems_label = "tetrahedron"
    vfaces = [TriangularFace(faces_label)]
    velems = [Tetrahedron(elems_label)]
    s_entities = StructuralEntity(velems, vfaces)
    entities_labels = [faces_label, elems_label]
    # -------------------------------
    # Mesh
    # -------------------------------
    filename = "uniaxial_compression"
    labels = [mat_label, entities_labels, bc_labels]
    local mesh_path
    output = @capture_out begin
        mesh_path = create_uniaxial_mesh(Li, Lj, Lk, labels, filename, ms)
    end
    gmsh_println(output)
    msh_file = MshFile(mesh_path)
    mesh = Mesh(msh_file, s_entities)
    # -------------------------------
    # Dofs
    #--------------------------------
    dof_dim = 3
    set_dofs!(mesh, :u, dof_dim)
    # -------------------------------
    # Structure
    # -------------------------------
    apply!(materials, mesh)
    apply!(s_boundary_conditions, mesh)
    s‚ÇÇ = Structure(mesh, materials, s_boundary_conditions)
    # -------------------------------
    # Structural Analysis
    # -------------------------------
    sa‚ÇÇ = NonLinearStaticAnalysis(s‚ÇÇ, load_factors(sa))
    reset!(sa‚ÇÇ)
    # -------------------------------
    # Numerical solution
    # -------------------------------
    states_sol_case‚ÇÇ = solve!(sa‚ÇÇ, nr)
    # Extract ‚Ñô and ‚ÑÇ from the last state using a random element
    e = rand(elements(s‚ÇÇ))
    # Numeric solution for testing
    numeric_Œ±_case‚ÇÇ, numeric_Œ≤_case‚ÇÇ, numeric_Œ≥_case‚ÇÇ, numeric_u·µ¢_case‚ÇÇ, _, _ = Œ±Œ≤Œ≥_numeric(states_sol_case‚ÇÇ)
    # Cosserat or second Piola-Kirchhoff stress tensor
    ‚Ñô_numeric_case‚ÇÇ = stress(states_sol_case‚ÇÇ, e)
    # ‚Ñô·µ¢·µ¢ component:
    ‚Ñô·µ¢·µ¢_numeric_case‚ÇÇ = getindex.(‚Ñô_numeric_case‚ÇÇ, 1, 1)
    # ‚Ñô‚±º‚±º component:
    ‚Ñô‚±º‚±º_numeric_case‚ÇÇ = getindex.(‚Ñô_numeric_case‚ÇÇ, 2, 2)
    # ‚Ñô‚Çñ‚Çñ component:
    ‚Ñô‚Çñ‚Çñ_numeric_case‚ÇÇ = getindex.(‚Ñô_numeric_case‚ÇÇ, 3, 3)
    # Get the Right hand Cauchy strain tensor ‚ÑÇ at a random state
    ‚ÑÇ_rand_numeric_case‚ÇÇ = rand(strain(states_sol_case‚ÇÇ, e))
    # Get the Second Piola Kirchhoff stress tensor ‚Ñô at a random state
    ‚Ñô_rand_numeric_case‚ÇÇ = rand(stress(states_sol_case‚ÇÇ, e))
    # Load factors
    load_factors_case‚ÇÇ = load_factors(sa‚ÇÇ)
    #-----------------------------
    # Analytic solution
    #-----------------------------
    "Computes displacements numeric solution u·µ¢, u‚±º and u‚Çñ for analytic validation."
    function u_ijk_numeric(numerical_Œ±::Vector{<:Real}, numerical_Œ≤::Vector{<:Real},
                           numerical_Œ≥::Vector{<:Real},
                           x::Real, y::Real, z::Real)
        x * (numerical_Œ± .- 1), y * (numerical_Œ≤ .- 1), z * (numerical_Œ≥ .- 1)
    end
    # Test with Second Piola-Kirchoff stress tensor `‚Ñô`.
    "Computes ‚Ñô(1,1) given Œ±, Œ≤ and Œ≥."
    function analytic_‚Ñô·µ¢·µ¢(Œ±::Vector{<:Real}, Œ≤::Vector{<:Real}, Œº::Real=Œº, K::Real=K)
        Œº * Œ± - Œº * (Œ± .^ (-1)) + K * (Œ≤ .^ 2) .* (Œ± .* (Œ≤ .^ 2) .- 1)
    end
    "Computes ‚Ñô(2,2) given Œ±, Œ≤ and Œ≥."
    function analytic_‚Ñô‚±º‚±º(Œ±::Vector{<:Real}, Œ≤::Vector{<:Real}, Œº::Real=Œº, K::Real=K)
        Œº * Œ≤ - Œº * (Œ≤ .^ (-1)) + K * Œ≤ .* ((Œ± .^ 2) .* (Œ≤ .^ 2) - Œ±)
    end
    "Computes ‚Ñô(2,2) given Œ±, Œ≤ and Œ≥."
    function analytic_‚Ñô‚Çñ‚Çñ(Œ±::Vector{<:Real}, Œ≤::Vector{<:Real}, Œº::Real=Œº, K::Real=K)
        analytic_‚Ñô‚±º‚±º(Œ±, Œ≤, Œº, K)
    end
    # Compute the analytic Second Piola-Kirchoff stress tensor `‚Ñô` for the numeric vectors Œ± and Œ≤
    # Case 1
    ‚Ñô·µ¢·µ¢_analytic_case‚ÇÅ = analytic_‚Ñô·µ¢·µ¢(numeric_Œ±_case‚ÇÅ, numeric_Œ≤_case‚ÇÅ)
    ‚Ñô‚±º‚±º_analytic_case‚ÇÅ = analytic_‚Ñô‚±º‚±º(numeric_Œ±_case‚ÇÅ, numeric_Œ≤_case‚ÇÅ)
    ‚Ñô‚Çñ‚Çñ_analytic_case‚ÇÅ = analytic_‚Ñô‚Çñ‚Çñ(numeric_Œ±_case‚ÇÅ, numeric_Œ≤_case‚ÇÅ)
    # Case 2
    ‚Ñô·µ¢·µ¢_analytic_case‚ÇÇ = analytic_‚Ñô·µ¢·µ¢(numeric_Œ±_case‚ÇÇ, numeric_Œ≤_case‚ÇÇ)
    ‚Ñô‚±º‚±º_analytic_case‚ÇÇ = analytic_‚Ñô‚±º‚±º(numeric_Œ±_case‚ÇÇ, numeric_Œ≤_case‚ÇÇ)
    ‚Ñô‚Çñ‚Çñ_analytic_case‚ÇÇ = analytic_‚Ñô‚Çñ‚Çñ(numeric_Œ±_case‚ÇÇ, numeric_Œ≤_case‚ÇÇ)
    # -------------------------------
    # Interpolator tests for Case 2
    #--------------------------------
    rand_point = [[rand() * Li, rand() * Lj, rand() * Lk]]
    eval_handler_rand = PointEvalHandler(mesh(s‚ÇÇ), rand_point)
    # Compute analytic solution at a random point
    u·µ¢_case‚ÇÇ, u‚±º_case‚ÇÇ, u‚Çñ_case‚ÇÇ = u_ijk_numeric(numeric_Œ±_case‚ÇÇ, numeric_Œ≤_case‚ÇÇ, numeric_Œ≥_case‚ÇÇ,
                                                 rand_point[]...)
    rand_point_u·µ¢ = displacements(states_sol_case‚ÇÇ, eval_handler_rand, 1)
    rand_point_u‚±º = displacements(states_sol_case‚ÇÇ, eval_handler_rand, 2)
    rand_point_u‚Çñ = displacements(states_sol_case‚ÇÇ, eval_handler_rand, 3)
    stress_point = stress(states_sol_case‚ÇÇ, eval_handler_rand)[]
    #-----------------------------
    # Test boolean for CI
    #-----------------------------
    @testset "Case 1 Uniaxial Compression Example" begin
        @test ‚Ñô·µ¢·µ¢_analytic_case‚ÇÅ ‚âà ‚Ñô·µ¢·µ¢_numeric_case‚ÇÅ rtol = RTOL
        @test ‚Ñô·µ¢·µ¢_analytic_case‚ÇÅ ‚âà ‚Ñô·µ¢·µ¢_numeric_case‚ÇÅ rtol = RTOL
        @test ‚Ñô‚±º‚±º_analytic_case‚ÇÅ ‚âà ‚Ñô‚±º‚±º_numeric_case‚ÇÅ atol = ATOL
        @test ‚Ñô‚Çñ‚Çñ_analytic_case‚ÇÅ ‚âà ‚Ñô‚Çñ‚Çñ_numeric_case‚ÇÅ atol = ATOL
        @test norm(‚Ñô‚±º‚±º_analytic_case‚ÇÅ) ‚âà 0 atol = ATOL
        @test norm(‚Ñô‚Çñ‚Çñ_analytic_case‚ÇÅ) ‚âà 0 atol = ATOL
        @test -p * load_factors_case‚ÇÅ ‚âà ‚Ñô·µ¢·µ¢_analytic_case‚ÇÅ rtol = RTOL
    end

    @testset "Case 2 Uniaxial Compression Example" begin
        @test ‚Ñô·µ¢·µ¢_analytic_case‚ÇÇ ‚âà ‚Ñô·µ¢·µ¢_numeric_case‚ÇÇ rtol = RTOL
        @test ‚Ñô·µ¢·µ¢_analytic_case‚ÇÇ ‚âà ‚Ñô·µ¢·µ¢_numeric_case‚ÇÇ rtol = RTOL
        @test ‚Ñô‚±º‚±º_analytic_case‚ÇÇ ‚âà ‚Ñô‚±º‚±º_numeric_case‚ÇÇ atol = ATOL
        @test ‚Ñô‚Çñ‚Çñ_analytic_case‚ÇÇ ‚âà ‚Ñô‚Çñ‚Çñ_numeric_case‚ÇÇ atol = ATOL
        @test norm(‚Ñô‚±º‚±º_analytic_case‚ÇÇ) ‚âà 0 atol = ATOL
        @test norm(‚Ñô‚Çñ‚Çñ_analytic_case‚ÇÇ) ‚âà 0 atol = ATOL
        @test -p * load_factors_case‚ÇÇ ‚âà ‚Ñô·µ¢·µ¢_analytic_case‚ÇÇ rtol = RTOL
        # Interpolation
        @test u·µ¢_case‚ÇÇ ‚âà rand_point_u·µ¢ rtol = RTOL
        @test u‚±º_case‚ÇÇ ‚âà rand_point_u‚±º rtol = RTOL
        @test u‚Çñ_case‚ÇÇ ‚âà rand_point_u‚Çñ rtol = RTOL
        @test getindex.(stress_point, 1) ‚âà ‚Ñô·µ¢·µ¢_analytic_case‚ÇÇ rtol = RTOL
    end
end

run_uniaxial_compression()

=#
