# ----------------------------- 
# Uniaxial Compression Example
# -----------------------------
using ONSAS.StaticAnalyses
using ONSAS.Utils: eye
using Test: @test, @testset
using LinearAlgebra: Symmetric, norm, det, tr
using Roots: find_zero
## scalar parameters
E = 1.0                    # Young modulus in Pa
ŒΩ = 0.3                    # Poisson's ratio
Œº = G = E / (2 * (1 + ŒΩ))  # Second Lam√© parameter 
K = E / (3 * (1 - 2 * ŒΩ))  # Bulk modulus
p = 5                      # Tension load in Pa
L·µ¢ = 2.0                   # Dimension in x of the box in m 
L‚±º = 1.0                   # Dimension in y of the box in m
L‚Çñ = 1.0                   # Dimension in z of the box in m
const RTOL = 1e-4          # Relative tolerance for tests
const ATOL = 1e-10         # Absolute tolerance for tests
const GENERATE_MSH = false # Boolean to generate the .msh form .geo
# -----------------------------------------------------
# Case 1 - Manufactured mesh and `NeoHookean` material
#------------------------------------------------------
# -------------------------------
# Mesh
#--------------------------------
n‚ÇÅ = Node(0.0, 0.0, 0.0)
n‚ÇÇ = Node(0.0, 0.0, L‚Çñ)
n‚ÇÉ = Node(0.0, L‚±º, L‚Çñ)
n‚ÇÑ = Node(0.0, L‚±º, 0.0)
n‚ÇÖ = Node(L·µ¢, 0.0, 0.0)
n‚ÇÜ = Node(L·µ¢, 0.0, L‚Çñ)
n‚Çá = Node(L·µ¢, L‚±º, L‚Çñ)
n‚Çà = Node(L·µ¢, L‚±º, 0.0)
vec_nodes = [n‚ÇÅ, n‚ÇÇ, n‚ÇÉ, n‚ÇÑ, n‚ÇÖ, n‚ÇÜ, n‚Çá, n‚Çà]
s‚ÇÅ_mesh = Mesh(vec_nodes)
## Faces 
f‚ÇÅ = TriangularFace(n‚ÇÖ, n‚Çà, n‚ÇÜ, "loaded_face_1")
f‚ÇÇ = TriangularFace(n‚ÇÜ, n‚Çà, n‚Çá, "loaded_face_2")
f‚ÇÉ = TriangularFace(n‚ÇÑ, n‚ÇÅ, n‚ÇÇ, "x=0_face_1")
f‚ÇÑ = TriangularFace(n‚ÇÑ, n‚ÇÇ, n‚ÇÉ, "x=0_face_2")
f‚ÇÖ = TriangularFace(n‚ÇÜ, n‚ÇÇ, n‚ÇÅ, "y=0_face_1")
f‚ÇÜ = TriangularFace(n‚ÇÜ, n‚ÇÅ, n‚ÇÖ, "y=0_face_2")
f‚Çá = TriangularFace(n‚ÇÅ, n‚ÇÑ, n‚ÇÖ, "z=0_face_1")
f‚Çà = TriangularFace(n‚ÇÑ, n‚Çà, n‚ÇÖ, "z=0_face_2")
vec_faces = [f‚ÇÅ, f‚ÇÇ, f‚ÇÉ, f‚ÇÑ, f‚ÇÖ, f‚ÇÜ, f‚Çá, f‚Çà]
push!(s‚ÇÅ_mesh, vec_faces)
## Elements 
t‚ÇÅ = Tetrahedron(n‚ÇÅ, n‚ÇÑ, n‚ÇÇ, n‚ÇÜ, "tetra_1")
t‚ÇÇ = Tetrahedron(n‚ÇÜ, n‚ÇÇ, n‚ÇÉ, n‚ÇÑ, "tetra_2")
t‚ÇÉ = Tetrahedron(n‚ÇÑ, n‚ÇÉ, n‚ÇÜ, n‚Çá, "tetra_3")
t‚ÇÑ = Tetrahedron(n‚ÇÑ, n‚ÇÅ, n‚ÇÖ, n‚ÇÜ, "tetra_4")
t‚ÇÖ = Tetrahedron(n‚ÇÑ, n‚ÇÜ, n‚ÇÖ, n‚Çà, "tetra_5")
t‚ÇÜ = Tetrahedron(n‚ÇÑ, n‚Çá, n‚ÇÜ, n‚Çà, "tetra_6")
vec_elems = [t‚ÇÅ, t‚ÇÇ, t‚ÇÉ, t‚ÇÑ, t‚ÇÖ, t‚ÇÜ]
push!(s‚ÇÅ_mesh, vec_elems)
# -------------------------------
# Dofs
#--------------------------------
dof_dim = 3
add!(s‚ÇÅ_mesh, :u, dof_dim)
# -------------------------------
# Materials
# -------------------------------
# Built neo hookian material with E and ŒΩ
neo_hookean = NeoHookean(K, Œº, "NeoBuiltIn")
mat_dict = dictionary([neo_hookean => [t‚ÇÅ, t‚ÇÇ, t‚ÇÉ, t‚ÇÑ, t‚ÇÖ, t‚ÇÜ]])
s‚ÇÅ_materials = StructuralMaterials(mat_dict)
# -------------------------------
# Boundary conditions
# -------------------------------
# Fixed dofs
bc‚ÇÅ = FixedDofBoundaryCondition([:u], [1], "fixed-ux")
bc‚ÇÇ = FixedDofBoundaryCondition([:u], [2], "fixed-uj")
bc‚ÇÉ = FixedDofBoundaryCondition([:u], [3], "fixed-uk")
# Load
bc‚ÇÑ = GlobalLoadBoundaryCondition([:u], t -> [p * t, 0, 0], "compression")
# Assign this to faces 
face_bc = dictionary([bc‚ÇÅ => [f‚ÇÉ, f‚ÇÑ], bc‚ÇÇ => [f‚ÇÖ, f‚ÇÜ], bc‚ÇÉ => [f‚Çá, f‚Çà], bc‚ÇÑ => [f‚ÇÅ, f‚ÇÇ]])
# Crete boundary conditions struct
s‚ÇÅ_boundary_conditions = StructuralBoundaryConditions(face_bcs=face_bc)
# -------------------------------
# Structure
# -------------------------------
s‚ÇÅ = Structure(s‚ÇÅ_mesh, s‚ÇÅ_materials, s‚ÇÅ_boundary_conditions)
# -------------------------------
# Structural Analysis
# -------------------------------
# Final load factor
NSTEPS = 8
sa‚ÇÅ = StaticAnalysis(s‚ÇÅ, NSTEPS=NSTEPS)
# Resets the analysis in order to run it multiple times
reset!(sa‚ÇÅ)
# -------------------------------
# Algorithm
# -------------------------------
tol_f = 1e-10;
tol_u = 1e-10;
max_iter = 30;
tols = ConvergenceSettings(tol_u, tol_f, max_iter)
nr = NewtonRaphson(tols)
# -------------------------------
# Numerical solution
# -------------------------------
states_sol_case‚ÇÅ = solve(sa‚ÇÅ, nr)
"Computes numeric solution Œ±(L_def/L_ref), Œ≤(L_def/L_ref) and Œ≥(L_def/L_ref)
 for analytic validation."
function Œ±Œ≤Œ≥_numeric(states_sol::AbstractSolution)
    s = structure(analysis(states_sol))
    # Node at (L·µ¢, L‚±º, L‚Çñ)
    n‚Çá = nodes(s)[7]
    displacements_n‚Çá = displacements(states_sol_case‚ÇÅ, n‚Çá)
    # Displacements in the x (component 1) axis at node 7
    numerical_u·µ¢ = displacements_n‚Çá[1]
    numerical_Œ± = 1 .+ numerical_u·µ¢ / L·µ¢
    # Displacements in the y (component 2) axis at node 7
    numerical_u‚±º = displacements_n‚Çá[2]
    numerical_Œ≤ = 1 .+ numerical_u‚±º / L‚±º
    # Displacements in the z (component 3) axis at node 7
    numerical_u‚Çñ = displacements_n‚Çá[3]
    numerical_Œ≥ = 1 .+ numerical_u‚Çñ / L‚Çñ
    return numerical_Œ±, numerical_Œ≤, numerical_Œ≥, numerical_u·µ¢, numerical_u‚±º, numerical_u‚Çñ
end
# Numeric solution for testing
numeric_Œ±_case‚ÇÅ, numeric_Œ≤_case‚ÇÅ, numeric_Œ≥_case‚ÇÅ, numeric_u·µ¢_case‚ÇÅ, _, _ = Œ±Œ≤Œ≥_numeric(states_sol_case‚ÇÅ)
# Extract ‚Ñô and ‚ÑÇ from the last state using a random element
e = rand(elements(s‚ÇÅ))
# Cosserat or second Piola-Kirchhoff stress tensor
‚Ñô_numeric_case‚ÇÅ = stress(states_sol_case‚ÇÅ, e)
# ‚Ñô·µ¢·µ¢ component: 
‚Ñô·µ¢·µ¢_numeric_case‚ÇÅ = getindex.(‚Ñô_numeric_case‚ÇÅ, 1, 1)
# ‚Ñô‚±º‚±º component: 
‚Ñô‚±º‚±º_numeric_case‚ÇÅ = getindex.(‚Ñô_numeric_case‚ÇÅ, 2, 2)
# ‚Ñô‚Çñ‚Çñ component: 
‚Ñô‚Çñ‚Çñ_numeric_case‚ÇÅ = getindex.(‚Ñô_numeric_case‚ÇÅ, 3, 3)
# Get the Right hand Cauchy strain tensor ‚ÑÇ at a random state 
‚ÑÇ_rand_numeric_case‚ÇÅ = rand(strain(states_sol_case‚ÇÅ, e))
# Get the Second Piola Kirchhoff stress tensor ‚Ñô at a random state 
‚Ñô_rand_numeric_case‚ÇÅ = rand(stress(states_sol_case‚ÇÅ, e))
# Load factors 
load_factors_case‚ÇÅ = load_factors(sa‚ÇÅ)
# -----------------------------------------------
# Case 2 - GMSH mesh and `HyperElastic` material
#------------------------------------------------
# -------------------------------
# Materials
# -------------------------------
# Define a new HyperElastic material from the strain energy function
"Neo-Hookean strain energy function given the Green-Lagrange strain
tensor `ùîº`, second lam√© parameter `Œº` and bulk modulus `K`."
function strain_energy_neo(ùîº::AbstractMatrix, K::Real, Œº::Real)
    # Right hand Cauchy strain tensor
    ‚ÑÇ = Symmetric(2 * ùîº + eye(3))
    J = sqrt(det(‚ÑÇ))
    # First invariant
    I‚ÇÅ = tr(‚ÑÇ)
    # Strain energy function 
    Œ® = Œº / 2 * (I‚ÇÅ - 2 * log(J)) + K / 2 * (J - 1)^2
end
params = [K, Œº] # The order must be the same defined in the strain energy (splatting)
neo_hookean_hyper = HyperElastic(params, strain_energy_neo, "neoHyper")
# Material types without assigned elements
mat_types = [neo_hookean_hyper]
s_materials = StructuralMaterials(mat_types)
# -------------------------------
# Boundary Conditions
# -------------------------------
# Redefine the load boundary condition 
bc‚ÇÑ = LocalPressureBoundaryCondition([:u], t -> [p * t], "tension")
# BoundaryConditions types without assigned node, feces and elements
vbc = [bc‚ÇÅ, bc‚ÇÇ, bc‚ÇÉ, bc‚ÇÑ]
s_boundary_conditions = StructuralBoundaryConditions(vbc)
# -------------------------------
# Entities
# -------------------------------
# Entities types without assigned nodes, faces and elements
vfaces = [TriangularFace("triangle")]
velems = [Tetrahedron("tetrahedron")]
s_entities = StructuralEntities(velems, vfaces)
# -------------------------------
# Mesh
# -------------------------------
file_name_msh = joinpath(@__DIR__, "uniaxial_compression.msh")
if GENERATE_MSH
    file_name_geo = joinpath(@__DIR__, "uniaxial_compression.geo")
    run(`gmsh -3 $file_name_geo -o $file_name`)
end
msh_file = MshFile(file_name_msh)
# -------------------------------
# Structure
# -------------------------------
s‚ÇÇ = Structure(msh_file, s_materials, s_boundary_conditions, s_entities)
# Final load factor
sa‚ÇÇ = StaticAnalysis(s‚ÇÇ, NSTEPS=NSTEPS)
reset!(sa‚ÇÇ)
# -------------------------------
# Numerical solution
# -------------------------------
# Extract ‚Ñô and ‚ÑÇ from the last state using a random element
e = rand(elements(s‚ÇÇ))
states_sol_case‚ÇÇ = solve(sa‚ÇÇ, nr)
# Numeric solution for testing
numeric_Œ±_case‚ÇÇ, numeric_Œ≤_case‚ÇÇ, numeric_Œ≥_case‚ÇÇ, numeric_u·µ¢_case‚ÇÇ, _, _ = Œ±Œ≤Œ≥_numeric(states_sol_case‚ÇÇ)
# Cosserat or second Piola-Kirchhoff stress tensor
‚Ñô_numeric_case‚ÇÇ = stress(states_sol_case‚ÇÇ, e)
# ‚Ñô·µ¢·µ¢ component: 
‚Ñô·µ¢·µ¢_numeric_case‚ÇÇ = getindex.(‚Ñô_numeric_case‚ÇÇ, 1, 1)
# ‚Ñô‚±º‚±º component: 
‚Ñô‚±º‚±º_numeric_case‚ÇÇ = getindex.(‚Ñô_numeric_case‚ÇÇ, 2, 2)
# ‚Ñô‚Çñ‚Çñ component: 
‚Ñô‚Çñ‚Çñ_numeric_case‚ÇÇ = getindex.(‚Ñô_numeric_case‚ÇÇ, 3, 3)
# Get the Right hand Cauchy strain tensor ‚ÑÇ at a random state 
‚ÑÇ_rand_numeric_case‚ÇÇ = rand(strain(states_sol_case‚ÇÇ, e))
# Get the Second Piola Kirchhoff stress tensor ‚Ñô at a random state 
‚Ñô_rand_numeric_case‚ÇÇ = rand(stress(states_sol_case‚ÇÇ, e))
# Load factors 
load_factors_case‚ÇÇ = load_factors(sa‚ÇÇ)
#-----------------------------
# Analytic solution  
#-----------------------------
# Test with Second Piola-Kirchoff stress tensor `‚Ñô`.
"Computes ‚Ñô(1,1) given Œ±, Œ≤ and Œ≥."
analytic_‚Ñô·µ¢·µ¢(Œ±::Vector{<:Real}, Œ≤::Vector{<:Real}, Œº::Real=Œº, K::Real=K) =
    Œº * Œ± - Œº * (Œ± .^ (-1)) + K * (Œ≤ .^ 2) .* (Œ± .* (Œ≤ .^ 2) .- 1)
"Computes ‚Ñô(2,2) given Œ±, Œ≤ and Œ≥."
analytic_‚Ñô‚±º‚±º(Œ±::Vector{<:Real}, Œ≤::Vector{<:Real}, Œº::Real=Œº, K::Real=K) =
    Œº * Œ≤ - Œº * (Œ≤ .^ (-1)) + K * Œ≤ .* ((Œ± .^ 2) .* (Œ≤ .^ 2) - Œ±)
"Computes ‚Ñô(2,2) given Œ±, Œ≤ and Œ≥."
analytic_‚Ñô‚Çñ‚Çñ(Œ±::Vector{<:Real}, Œ≤::Vector{<:Real}, Œº::Real=Œº, K::Real=K) =
    analytic_‚Ñô‚±º‚±º(Œ±, Œ≤, Œº, K)
# Compute the analytic Second Piola-Kirchoff stress tensor `‚Ñô` for the numeric vectors Œ± and Œ≤
# Case 1 
‚Ñô·µ¢·µ¢_analytic_case‚ÇÅ = analytic_‚Ñô·µ¢·µ¢(numeric_Œ±_case‚ÇÅ, numeric_Œ≤_case‚ÇÅ)
‚Ñô‚±º‚±º_analytic_case‚ÇÅ = analytic_‚Ñô‚±º‚±º(numeric_Œ±_case‚ÇÅ, numeric_Œ≤_case‚ÇÅ)
‚Ñô‚Çñ‚Çñ_analytic_case‚ÇÅ = analytic_‚Ñô‚Çñ‚Çñ(numeric_Œ±_case‚ÇÅ, numeric_Œ≤_case‚ÇÅ)
# Case 2 
‚Ñô·µ¢·µ¢_analytic_case‚ÇÇ = analytic_‚Ñô·µ¢·µ¢(numeric_Œ±_case‚ÇÇ, numeric_Œ≤_case‚ÇÇ)
‚Ñô‚±º‚±º_analytic_case‚ÇÇ = analytic_‚Ñô‚±º‚±º(numeric_Œ±_case‚ÇÇ, numeric_Œ≤_case‚ÇÇ)
‚Ñô‚Çñ‚Çñ_analytic_case‚ÇÇ = analytic_‚Ñô‚Çñ‚Çñ(numeric_Œ±_case‚ÇÇ, numeric_Œ≤_case‚ÇÇ)
#-----------------------------
# Test boolean for CI  
#-----------------------------

@testset "Case 1 Uniaxial Compression Example" begin
    @test ‚Ñô·µ¢·µ¢_analytic_case‚ÇÅ ‚âà ‚Ñô·µ¢·µ¢_numeric_case‚ÇÅ rtol = RTOL
    @test ‚Ñô·µ¢·µ¢_analytic_case‚ÇÅ ‚âà ‚Ñô·µ¢·µ¢_numeric_case‚ÇÅ rtol = RTOL
    @test ‚Ñô‚±º‚±º_analytic_case‚ÇÅ ‚âà ‚Ñô‚±º‚±º_numeric_case‚ÇÅ atol = ATOL
    @test ‚Ñô‚Çñ‚Çñ_analytic_case‚ÇÅ ‚âà ‚Ñô‚Çñ‚Çñ_numeric_case‚ÇÅ atol = ATOL
    @test norm(‚Ñô‚±º‚±º_analytic_case‚ÇÅ) ‚âà 0 atol = ATOL
    @test norm(‚Ñô‚Çñ‚Çñ_analytic_case‚ÇÅ) ‚âà 0 atol = ATOL
    @test p * load_factors_case‚ÇÅ ‚âà ‚Ñô·µ¢·µ¢_analytic_case‚ÇÅ rtol = RTOL
end

@testset "Case 2 Uniaxial Compression Example" begin
    @test ‚Ñô·µ¢·µ¢_analytic_case‚ÇÇ ‚âà ‚Ñô·µ¢·µ¢_numeric_case‚ÇÇ rtol = RTOL
    @test ‚Ñô·µ¢·µ¢_analytic_case‚ÇÇ ‚âà ‚Ñô·µ¢·µ¢_numeric_case‚ÇÇ rtol = RTOL
    @test ‚Ñô‚±º‚±º_analytic_case‚ÇÇ ‚âà ‚Ñô‚±º‚±º_numeric_case‚ÇÇ atol = ATOL
    @test ‚Ñô‚Çñ‚Çñ_analytic_case‚ÇÇ ‚âà ‚Ñô‚Çñ‚Çñ_numeric_case‚ÇÇ atol = ATOL
    @test norm(‚Ñô‚±º‚±º_analytic_case‚ÇÇ) ‚âà 0 atol = ATOL
    @test norm(‚Ñô‚Çñ‚Çñ_analytic_case‚ÇÇ) ‚âà 0 atol = ATOL
    @test p * load_factors_case‚ÇÇ ‚âà ‚Ñô·µ¢·µ¢_analytic_case‚ÇÇ rtol = RTOL
end

